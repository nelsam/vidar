// This file was generated by github.com/nelsam/hel.  Do not
// edit this code by hand unless you *really* know what you're
// doing.  Expect any changes made manually to be overwritten
// the next time hel regenerates this file.

package focus_test

import (
	"github.com/nelsam/vidar/bind"
	"github.com/nelsam/vidar/input"
)

type mockOpener struct {
	OpenCalled chan bool
	OpenInput  struct {
		Arg0 chan string
	}
}

func newMockOpener() *mockOpener {
	m := &mockOpener{}
	m.OpenCalled = make(chan bool, 100)
	m.OpenInput.Arg0 = make(chan string, 100)
	return m
}
func (m *mockOpener) Open(arg0 string) {
	m.OpenCalled <- true
	m.OpenInput.Arg0 <- arg0
}

type mockEditorOpener struct {
	OpenCalled chan bool
	OpenInput  struct {
		Arg0 chan string
	}
	OpenOutput struct {
		Editor  chan input.Editor
		Existed chan bool
	}
	CurrentEditorCalled chan bool
	CurrentEditorOutput struct {
		Ret0 chan input.Editor
	}
}

func newMockEditorOpener() *mockEditorOpener {
	m := &mockEditorOpener{}
	m.OpenCalled = make(chan bool, 100)
	m.OpenInput.Arg0 = make(chan string, 100)
	m.OpenOutput.Editor = make(chan input.Editor, 100)
	m.OpenOutput.Existed = make(chan bool, 100)
	m.CurrentEditorCalled = make(chan bool, 100)
	m.CurrentEditorOutput.Ret0 = make(chan input.Editor, 100)
	return m
}
func (m *mockEditorOpener) Open(arg0 string) (editor input.Editor, existed bool) {
	m.OpenCalled <- true
	m.OpenInput.Arg0 <- arg0
	return <-m.OpenOutput.Editor, <-m.OpenOutput.Existed
}
func (m *mockEditorOpener) CurrentEditor() input.Editor {
	m.CurrentEditorCalled <- true
	return <-m.CurrentEditorOutput.Ret0
}

type mockBinder struct {
	PushCalled chan bool
	PushInput  struct {
		Arg0 chan []bind.Bindable
	}
	PopCalled chan bool
	PopOutput struct {
		Ret0 chan []bind.Bindable
	}
	ExecuteCalled chan bool
	ExecuteInput  struct {
		Arg0 chan bind.Bindable
	}
}

func newMockBinder() *mockBinder {
	m := &mockBinder{}
	m.PushCalled = make(chan bool, 100)
	m.PushInput.Arg0 = make(chan []bind.Bindable, 100)
	m.PopCalled = make(chan bool, 100)
	m.PopOutput.Ret0 = make(chan []bind.Bindable, 100)
	m.ExecuteCalled = make(chan bool, 100)
	m.ExecuteInput.Arg0 = make(chan bind.Bindable, 100)
	return m
}
func (m *mockBinder) Push(arg0 ...bind.Bindable) {
	m.PushCalled <- true
	m.PushInput.Arg0 <- arg0
}
func (m *mockBinder) Pop() []bind.Bindable {
	m.PopCalled <- true
	return <-m.PopOutput.Ret0
}
func (m *mockBinder) Execute(arg0 bind.Bindable) {
	m.ExecuteCalled <- true
	m.ExecuteInput.Arg0 <- arg0
}

type mockFileChanger struct {
	FileChangedCalled chan bool
	FileChangedInput  struct {
		OldPath, NewPath chan string
	}
}

func newMockFileChanger() *mockFileChanger {
	m := &mockFileChanger{}
	m.FileChangedCalled = make(chan bool, 100)
	m.FileChangedInput.OldPath = make(chan string, 100)
	m.FileChangedInput.NewPath = make(chan string, 100)
	return m
}
func (m *mockFileChanger) FileChanged(oldPath, newPath string) {
	m.FileChangedCalled <- true
	m.FileChangedInput.OldPath <- oldPath
	m.FileChangedInput.NewPath <- newPath
}

type mockFileBinder struct {
	FileBindablesCalled chan bool
	FileBindablesInput  struct {
		Path chan string
	}
	FileBindablesOutput struct {
		Ret0 chan []bind.Bindable
	}
}

func newMockFileBinder() *mockFileBinder {
	m := &mockFileBinder{}
	m.FileBindablesCalled = make(chan bool, 100)
	m.FileBindablesInput.Path = make(chan string, 100)
	m.FileBindablesOutput.Ret0 = make(chan []bind.Bindable, 100)
	return m
}
func (m *mockFileBinder) FileBindables(path string) []bind.Bindable {
	m.FileBindablesCalled <- true
	m.FileBindablesInput.Path <- path
	return <-m.FileBindablesOutput.Ret0
}

type mockLineStarter struct {
	LineStartCalled chan bool
	LineStartInput  struct {
		Arg0 chan int
	}
	LineStartOutput struct {
		Ret0 chan int
	}
}

func newMockLineStarter() *mockLineStarter {
	m := &mockLineStarter{}
	m.LineStartCalled = make(chan bool, 100)
	m.LineStartInput.Arg0 = make(chan int, 100)
	m.LineStartOutput.Ret0 = make(chan int, 100)
	return m
}
func (m *mockLineStarter) LineStart(arg0 int) int {
	m.LineStartCalled <- true
	m.LineStartInput.Arg0 <- arg0
	return <-m.LineStartOutput.Ret0
}

type mockMover struct {
	ToCalled chan bool
	ToInput  struct {
		Arg0 chan []int
	}
	ToOutput struct {
		Ret0 chan bind.Bindable
	}
}

func newMockMover() *mockMover {
	m := &mockMover{}
	m.ToCalled = make(chan bool, 100)
	m.ToInput.Arg0 = make(chan []int, 100)
	m.ToOutput.Ret0 = make(chan bind.Bindable, 100)
	return m
}
func (m *mockMover) To(arg0 ...int) bind.Bindable {
	m.ToCalled <- true
	m.ToInput.Arg0 <- arg0
	return <-m.ToOutput.Ret0
}

type mockEditor struct {
	FilepathCalled chan bool
	FilepathOutput struct {
		Ret0 chan string
	}
	TextCalled chan bool
	TextOutput struct {
		Ret0 chan string
	}
	SetTextCalled chan bool
	SetTextInput  struct {
		Arg0 chan string
	}
	SyntaxLayersCalled chan bool
	SyntaxLayersOutput struct {
		Ret0 chan []input.SyntaxLayer
	}
	SetSyntaxLayersCalled chan bool
	SetSyntaxLayersInput  struct {
		Arg0 chan []input.SyntaxLayer
	}
}

func newMockEditor() *mockEditor {
	m := &mockEditor{}
	m.FilepathCalled = make(chan bool, 100)
	m.FilepathOutput.Ret0 = make(chan string, 100)
	m.TextCalled = make(chan bool, 100)
	m.TextOutput.Ret0 = make(chan string, 100)
	m.SetTextCalled = make(chan bool, 100)
	m.SetTextInput.Arg0 = make(chan string, 100)
	m.SyntaxLayersCalled = make(chan bool, 100)
	m.SyntaxLayersOutput.Ret0 = make(chan []input.SyntaxLayer, 100)
	m.SetSyntaxLayersCalled = make(chan bool, 100)
	m.SetSyntaxLayersInput.Arg0 = make(chan []input.SyntaxLayer, 100)
	return m
}
func (m *mockEditor) Filepath() string {
	m.FilepathCalled <- true
	return <-m.FilepathOutput.Ret0
}
func (m *mockEditor) Text() string {
	m.TextCalled <- true
	return <-m.TextOutput.Ret0
}
func (m *mockEditor) SetText(arg0 string) {
	m.SetTextCalled <- true
	m.SetTextInput.Arg0 <- arg0
}
func (m *mockEditor) SyntaxLayers() []input.SyntaxLayer {
	m.SyntaxLayersCalled <- true
	return <-m.SyntaxLayersOutput.Ret0
}
func (m *mockEditor) SetSyntaxLayers(arg0 []input.SyntaxLayer) {
	m.SetSyntaxLayersCalled <- true
	m.SetSyntaxLayersInput.Arg0 <- arg0
}

type mockBindable struct {
	NameCalled chan bool
	NameOutput struct {
		Ret0 chan string
	}
}

func newMockBindable() *mockBindable {
	m := &mockBindable{}
	m.NameCalled = make(chan bool, 100)
	m.NameOutput.Ret0 = make(chan string, 100)
	return m
}
func (m *mockBindable) Name() string {
	m.NameCalled <- true
	return <-m.NameOutput.Ret0
}
